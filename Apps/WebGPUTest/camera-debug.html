<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>WebGPU Camera Debug - Multiple Cubes</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        font-family: sans-serif;
        background: #1a1a1a;
        color: white;
      }

      #container {
        width: 100vw;
        height: 100vh;
        display: flex;
        flex-direction: column;
      }

      #info {
        padding: 20px;
        background: rgba(42, 42, 42, 0.95);
        border-bottom: 2px solid #4a90e2;
      }

      #info h1 {
        margin: 0 0 10px 0;
        font-size: 24px;
        color: #67b7ff;
      }

      #canvas {
        flex: 1;
        display: block;
      }

      #log {
        position: absolute;
        bottom: 10px;
        right: 10px;
        background: rgba(42, 42, 42, 0.95);
        padding: 15px;
        border-radius: 6px;
        max-width: 400px;
        font-size: 11px;
        max-height: 400px;
        overflow-y: auto;
      }
    </style>
  </head>
  <body>
    <div id="container">
      <div id="info">
        <h1>üîç WebGPU Camera Debug</h1>
        <p>Multiple cubes at different positions to test camera/projection</p>
        <p><strong>Camera:</strong> (0, 1, 3) looking at (0, 0, 0)</p>
      </div>
      <canvas id="canvas"></canvas>
    </div>

    <div id="log">
      <strong>Cube Positions:</strong>
    </div>

    <script type="module">
      const canvas = document.getElementById("canvas");
      const logEl = document.getElementById("log");

      function resize() {
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
      }
      resize();
      window.addEventListener("resize", resize);

      function log(msg) {
        const entry = document.createElement("div");
        entry.style.margin = "3px 0";
        entry.style.color = msg.startsWith("‚úì")
          ? "#5FD35F"
          : msg.startsWith("üìç")
            ? "#FFD700"
            : "#67B7FF";
        entry.textContent = msg;
        logEl.appendChild(entry);
        console.log(msg);
      }

      async function main() {
        try {
          log("üöÄ Camera Debug Test Starting...");

          const adapter = await navigator.gpu.requestAdapter();
          const device = await adapter.requestDevice();
          const context = canvas.getContext("webgpu");
          const format = navigator.gpu.getPreferredCanvasFormat();
          context.configure({ device, format });
          log("‚úì WebGPU initialized");

          // Single cube vertices (0.3 unit size for small cubes)
          const size = 0.3;
          const vertices = new Float32Array([
            // Front (red), Back (cyan), Top (green), Bottom (magenta), Right (blue), Left (yellow)
            -size,
            -size,
            size,
            1,
            0,
            0,
            size,
            -size,
            size,
            1,
            0,
            0,
            size,
            size,
            size,
            1,
            0,
            0,
            -size,
            size,
            size,
            1,
            0,
            0,
            -size,
            -size,
            -size,
            0,
            1,
            1,
            size,
            -size,
            -size,
            0,
            1,
            1,
            size,
            size,
            -size,
            0,
            1,
            1,
            -size,
            size,
            -size,
            0,
            1,
            1,
            -size,
            size,
            -size,
            0,
            1,
            0,
            -size,
            size,
            size,
            0,
            1,
            0,
            size,
            size,
            size,
            0,
            1,
            0,
            size,
            size,
            -size,
            0,
            1,
            0,
            -size,
            -size,
            -size,
            1,
            0,
            1,
            -size,
            -size,
            size,
            1,
            0,
            1,
            size,
            -size,
            size,
            1,
            0,
            1,
            size,
            -size,
            -size,
            1,
            0,
            1,
            size,
            -size,
            -size,
            0,
            0,
            1,
            size,
            size,
            -size,
            0,
            0,
            1,
            size,
            size,
            size,
            0,
            0,
            1,
            size,
            -size,
            size,
            0,
            0,
            1,
            -size,
            -size,
            -size,
            1,
            1,
            0,
            -size,
            size,
            -size,
            1,
            1,
            0,
            -size,
            size,
            size,
            1,
            1,
            0,
            -size,
            -size,
            size,
            1,
            1,
            0,
          ]);

          const indices = new Uint16Array([
            0, 1, 2, 0, 2, 3, 4, 6, 5, 4, 7, 6, 8, 9, 10, 8, 10, 11, 12, 14, 13,
            12, 15, 14, 16, 17, 18, 16, 18, 19, 20, 22, 21, 20, 23, 22,
          ]);

          // Cube positions to test
          const cubePositions = [
            { pos: [0, 0, 0], desc: "Origin" },
            { pos: [0, 0, -1], desc: "1 unit in front" },
            { pos: [0, 0, -2], desc: "2 units in front" },
            { pos: [0, 0, -5], desc: "5 units in front" },
            { pos: [0, 0, -10], desc: "10 units in front" },
            { pos: [2, 0, 0], desc: "2 units right" },
            { pos: [-2, 0, 0], desc: "2 units left" },
            { pos: [0, 2, 0], desc: "2 units up" },
            { pos: [0, -2, 0], desc: "2 units down" },
            { pos: [1, 1, -2], desc: "Diagonal (1,1,-2)" },
          ];

          cubePositions.forEach((cube) => {
            log(
              `üìç ${cube.desc}: (${cube.pos[0]}, ${cube.pos[1]}, ${cube.pos[2]})`,
            );
          });

          const vertexBuffer = device.createBuffer({
            size: vertices.byteLength,
            usage: GPUBufferUsage.VERTEX,
            mappedAtCreation: true,
          });
          new Float32Array(vertexBuffer.getMappedRange()).set(vertices);
          vertexBuffer.unmap();

          const indexBuffer = device.createBuffer({
            size: indices.byteLength,
            usage: GPUBufferUsage.INDEX,
            mappedAtCreation: true,
          });
          new Uint16Array(indexBuffer.getMappedRange()).set(indices);
          indexBuffer.unmap();

          const uniformBuffer = device.createBuffer({
            size: 64,
            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
          });
          log("‚úì Buffers created");

          const shaderCode = `
          struct Uniforms {
            mvpMatrix: mat4x4<f32>,
          }
          
          @group(0) @binding(0) var<uniform> uniforms: Uniforms;

          struct VertexInput {
            @location(0) position: vec3<f32>,
            @location(1) color: vec3<f32>,
          }

          struct VertexOutput {
            @builtin(position) position: vec4<f32>,
            @location(0) color: vec3<f32>,
          }

          @vertex
          fn vertexMain(input: VertexInput) -> VertexOutput {
            var output: VertexOutput;
            output.position = uniforms.mvpMatrix * vec4<f32>(input.position, 1.0);
            output.color = input.color;
            return output;
          }

          @fragment
          fn fragmentMain(input: VertexOutput) -> @location(0) vec4<f32> {
            return vec4<f32>(input.color, 1.0);
          }
        `;

          const shaderModule = device.createShaderModule({ code: shaderCode });

          const bindGroupLayout = device.createBindGroupLayout({
            entries: [
              {
                binding: 0,
                visibility: GPUShaderStage.VERTEX,
                buffer: { type: "uniform" },
              },
            ],
          });

          const bindGroup = device.createBindGroup({
            layout: bindGroupLayout,
            entries: [{ binding: 0, resource: { buffer: uniformBuffer } }],
          });

          const depthTexture = device.createTexture({
            size: [canvas.width, canvas.height],
            format: "depth24plus",
            usage: GPUTextureUsage.RENDER_ATTACHMENT,
          });

          const pipeline = device.createRenderPipeline({
            layout: device.createPipelineLayout({
              bindGroupLayouts: [bindGroupLayout],
            }),
            vertex: {
              module: shaderModule,
              entryPoint: "vertexMain",
              buffers: [
                {
                  arrayStride: 6 * 4,
                  attributes: [
                    { shaderLocation: 0, offset: 0, format: "float32x3" },
                    { shaderLocation: 1, offset: 3 * 4, format: "float32x3" },
                  ],
                },
              ],
            },
            fragment: {
              module: shaderModule,
              entryPoint: "fragmentMain",
              targets: [{ format }],
            },
            primitive: { topology: "triangle-list", cullMode: "none" },
            depthStencil: {
              format: "depth24plus",
              depthWriteEnabled: true,
              depthCompare: "less",
            },
          });

          log("‚úì Pipeline created");

          // Matrix functions
          function normalize(v) {
            const len = Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
            return [v[0] / len, v[1] / len, v[2] / len];
          }

          function subtract(a, b) {
            return [a[0] - b[0], a[1] - b[1], a[2] - b[2]];
          }

          function cross(a, b) {
            return [
              a[1] * b[2] - a[2] * b[1],
              a[2] * b[0] - a[0] * b[2],
              a[0] * b[1] - a[1] * b[0],
            ];
          }

          function dot(a, b) {
            return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
          }

          function createLookAt(eye, target, up) {
            const zAxis = normalize(subtract(eye, target));
            const xAxis = normalize(cross(up, zAxis));
            const yAxis = cross(zAxis, xAxis);

            return new Float32Array([
              xAxis[0],
              yAxis[0],
              zAxis[0],
              0,
              xAxis[1],
              yAxis[1],
              zAxis[1],
              0,
              xAxis[2],
              yAxis[2],
              zAxis[2],
              0,
              -dot(xAxis, eye),
              -dot(yAxis, eye),
              -dot(zAxis, eye),
              1,
            ]);
          }

          function createPerspective(fov, aspect, near, far) {
            const f = 1.0 / Math.tan(fov / 2);
            const rangeInv = 1.0 / (near - far);

            return new Float32Array([
              f / aspect,
              0,
              0,
              0,
              0,
              f,
              0,
              0,
              0,
              0,
              far * rangeInv,
              -1,
              0,
              0,
              near * far * rangeInv,
              0,
            ]);
          }

          function createTranslation(x, y, z) {
            return new Float32Array([
              1,
              0,
              0,
              0,
              0,
              1,
              0,
              0,
              0,
              0,
              1,
              0,
              x,
              y,
              z,
              1,
            ]);
          }

          function multiplyMatrices(a, b) {
            const result = new Float32Array(16);
            for (let i = 0; i < 4; i++) {
              for (let j = 0; j < 4; j++) {
                result[i * 4 + j] =
                  a[i * 4 + 0] * b[0 * 4 + j] +
                  a[i * 4 + 1] * b[1 * 4 + j] +
                  a[i * 4 + 2] * b[2 * 4 + j] +
                  a[i * 4 + 3] * b[3 * 4 + j];
              }
            }
            return result;
          }

          log("‚úì Rendering...");

          function render() {
            // Camera setup
            const eye = [0, 1, 3];
            const target = [0, 0, 0];
            const up = [0, 1, 0];
            const viewMatrix = createLookAt(eye, target, up);

            const aspect = canvas.width / canvas.height;
            const projectionMatrix = createPerspective(
              Math.PI / 4,
              aspect,
              0.1,
              100.0,
            );

            // Render
            const commandEncoder = device.createCommandEncoder();
            const textureView = context.getCurrentTexture().createView();
            const depthView = depthTexture.createView();

            const renderPass = commandEncoder.beginRenderPass({
              colorAttachments: [
                {
                  view: textureView,
                  clearValue: { r: 0.1, g: 0.1, b: 0.15, a: 1.0 },
                  loadOp: "clear",
                  storeOp: "store",
                },
              ],
              depthStencilAttachment: {
                view: depthView,
                depthClearValue: 1.0,
                depthLoadOp: "clear",
                depthStoreOp: "store",
              },
            });

            renderPass.setPipeline(pipeline);
            renderPass.setBindGroup(0, bindGroup);
            renderPass.setVertexBuffer(0, vertexBuffer);
            renderPass.setIndexBuffer(indexBuffer, "uint16");

            // Draw each cube at its position
            cubePositions.forEach((cube) => {
              const modelMatrix = createTranslation(
                cube.pos[0],
                cube.pos[1],
                cube.pos[2],
              );
              let mvpMatrix = multiplyMatrices(viewMatrix, modelMatrix);
              mvpMatrix = multiplyMatrices(projectionMatrix, mvpMatrix);

              device.queue.writeBuffer(uniformBuffer, 0, mvpMatrix);
              renderPass.drawIndexed(36);
            });

            renderPass.end();
            device.queue.submit([commandEncoder.finish()]);

            requestAnimationFrame(render);
          }

          requestAnimationFrame(render);
          log("‚úì If you see ANY cubes, note their positions!");
        } catch (error) {
          console.error("Error:", error);
          log(`‚úó Error: ${error.message}`);
        }
      }

      main();
    </script>
  </body>
</html>
