<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>WebGPU Triangle Test - Phase 3.5</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        font-family: sans-serif;
        background: #1a1a1a;
        color: white;
      }

      #container {
        width: 100vw;
        height: 100vh;
        display: flex;
        flex-direction: column;
      }

      #info {
        padding: 20px;
        background: rgba(42, 42, 42, 0.95);
        border-bottom: 2px solid #4a90e2;
      }

      #info h1 {
        margin: 0 0 10px 0;
        font-size: 24px;
        color: #67b7ff;
      }

      #info p {
        margin: 5px 0;
        font-size: 14px;
        color: #aaa;
      }

      .status {
        display: inline-block;
        padding: 4px 12px;
        border-radius: 4px;
        font-size: 12px;
        font-weight: 600;
        margin-left: 10px;
      }

      .status-success {
        background: #2d5f2e;
        color: #5fd35f;
      }

      .status-error {
        background: #5f2d2d;
        color: #ff6b6b;
      }

      #canvas {
        flex: 1;
        display: block;
      }

      #log {
        position: absolute;
        bottom: 10px;
        right: 10px;
        background: rgba(42, 42, 42, 0.95);
        padding: 15px;
        border-radius: 6px;
        max-width: 400px;
        max-height: 300px;
        overflow-y: auto;
        font-size: 12px;
        line-height: 1.6;
      }

      .log-entry {
        margin: 5px 0;
        padding: 5px;
        border-left: 3px solid #4a90e2;
        padding-left: 10px;
      }

      .log-success {
        border-color: #5fd35f;
        color: #5fd35f;
      }
      .log-error {
        border-color: #ff6b6b;
        color: #ff6b6b;
      }
      .log-warning {
        border-color: #ffa500;
        color: #ffa500;
      }
      .log-info {
        border-color: #67b7ff;
        color: #67b7ff;
      }
    </style>
  </head>
  <body>
    <div id="container">
      <div id="info">
        <h1>
          ðŸ”º WebGPU Triangle Test
          <span class="status" id="status">Initializing...</span>
        </h1>
        <p>Phase 3.5: Basic Rendering Pipeline Validation</p>
        <p>
          This test validates the complete WebGPU rendering stack: Context â†’
          Buffer â†’ Shader â†’ Pipeline â†’ Draw Command â†’ Render
        </p>
      </div>
      <canvas id="canvas"></canvas>
    </div>

    <div id="log">
      <strong>Initialization Log:</strong>
    </div>

    <script type="module">
      const canvas = document.getElementById("canvas");
      const statusEl = document.getElementById("status");
      const logEl = document.getElementById("log");

      // Resize canvas to fill container
      function resize() {
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
      }
      resize();
      window.addEventListener("resize", resize);

      function log(message, type = "info") {
        const entry = document.createElement("div");
        entry.className = `log-entry log-${type}`;
        entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
        logEl.appendChild(entry);
        logEl.scrollTop = logEl.scrollHeight;
        console.log(`[${type.toUpperCase()}] ${message}`);
      }

      function setStatus(text, success) {
        statusEl.textContent = text;
        statusEl.className = `status ${success ? "status-success" : "status-error"}`;
      }

      async function initWebGPU() {
        try {
          log("Checking WebGPU availability...", "info");

          if (!navigator.gpu) {
            throw new Error("WebGPU is not supported in this browser");
          }

          log("âœ“ WebGPU API detected", "success");

          // Request adapter
          log("Requesting GPU adapter...", "info");
          const adapter = await navigator.gpu.requestAdapter({
            powerPreference: "high-performance",
          });

          if (!adapter) {
            throw new Error("Failed to get GPU adapter");
          }

          log(`âœ“ Adapter: ${adapter.name ?? "Unknown GPU"}`, "success");

          // Request device
          log("Requesting GPU device...", "info");
          const device = await adapter.requestDevice();

          log("âœ“ Device acquired", "success");

          // Configure canvas
          log("Configuring canvas context...", "info");
          const context = canvas.getContext("webgpu");

          if (!context) {
            throw new Error("Failed to get WebGPU context");
          }

          const format = navigator.gpu.getPreferredCanvasFormat();
          context.configure({
            device: device,
            format: format,
            alphaMode: "opaque",
          });

          log(`âœ“ Canvas configured (${format})`, "success");

          return { device, context, format };
        } catch (error) {
          log(`âœ— WebGPU initialization failed: ${error.message}`, "error");
          setStatus("WebGPU Not Available", false);
          throw error;
        }
      }

      async function createTriangle(device, format) {
        log("Creating triangle geometry...", "info");

        // Vertex data: position (x, y) and color (r, g, b)
        const vertices = new Float32Array([
          // x,    y,     r,    g,    b
          0.0,
          0.6,
          1.0,
          0.0,
          0.0, // Top (red)
          -0.6,
          -0.6,
          0.0,
          1.0,
          0.0, // Bottom-left (green)
          0.6,
          -0.6,
          0.0,
          0.0,
          1.0, // Bottom-right (blue)
        ]);

        // Create vertex buffer
        const vertexBuffer = device.createBuffer({
          size: vertices.byteLength,
          usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
          mappedAtCreation: true,
        });
        new Float32Array(vertexBuffer.getMappedRange()).set(vertices);
        vertexBuffer.unmap();

        log("âœ“ Vertex buffer created (3 vertices)", "success");

        // Shader code (WGSL)
        const shaderCode = `
        struct VertexInput {
          @location(0) position: vec2<f32>,
          @location(1) color: vec3<f32>,
        }

        struct VertexOutput {
          @builtin(position) position: vec4<f32>,
          @location(0) color: vec3<f32>,
        }

        @vertex
        fn vertexMain(input: VertexInput) -> VertexOutput {
          var output: VertexOutput;
          output.position = vec4<f32>(input.position, 0.0, 1.0);
          output.color = input.color;
          return output;
        }

        @fragment
        fn fragmentMain(input: VertexOutput) -> @location(0) vec4<f32> {
          return vec4<f32>(input.color, 1.0);
        }
      `;

        const shaderModule = device.createShaderModule({
          code: shaderCode,
        });

        log("âœ“ Shader module created (WGSL)", "success");

        // Create render pipeline
        const pipeline = device.createRenderPipeline({
          layout: "auto",
          vertex: {
            module: shaderModule,
            entryPoint: "vertexMain",
            buffers: [
              {
                arrayStride: 5 * 4, // 5 floats per vertex * 4 bytes
                attributes: [
                  {
                    shaderLocation: 0,
                    offset: 0,
                    format: "float32x2", // position
                  },
                  {
                    shaderLocation: 1,
                    offset: 2 * 4, // offset past position
                    format: "float32x3", // color
                  },
                ],
              },
            ],
          },
          fragment: {
            module: shaderModule,
            entryPoint: "fragmentMain",
            targets: [
              {
                format: format,
              },
            ],
          },
          primitive: {
            topology: "triangle-list",
          },
        });

        log("âœ“ Render pipeline created", "success");

        return { vertexBuffer, pipeline };
      }

      function render(device, context, pipeline, vertexBuffer) {
        // Get current texture
        const textureView = context.getCurrentTexture().createView();

        // Create command encoder
        const commandEncoder = device.createCommandEncoder();

        // Begin render pass
        const renderPass = commandEncoder.beginRenderPass({
          colorAttachments: [
            {
              view: textureView,
              clearValue: { r: 0.1, g: 0.1, b: 0.15, a: 1.0 }, // Dark blue background
              loadOp: "clear",
              storeOp: "store",
            },
          ],
        });

        // Set pipeline and vertex buffer
        renderPass.setPipeline(pipeline);
        renderPass.setVertexBuffer(0, vertexBuffer);

        // Draw the triangle (3 vertices, 1 instance)
        renderPass.draw(3, 1, 0, 0);

        // End render pass
        renderPass.end();

        // Submit commands
        device.queue.submit([commandEncoder.finish()]);
      }

      // Main initialization and render
      async function main() {
        try {
          log("=== Phase 3.5: Basic WebGPU Rendering Test ===", "info");

          // Initialize WebGPU
          const { device, context, format } = await initWebGPU();
          setStatus("WebGPU Active", true);

          // Create triangle
          const { vertexBuffer, pipeline } = await createTriangle(
            device,
            format,
          );

          // Render the triangle
          log("Rendering triangle...", "info");
          render(device, context, pipeline, vertexBuffer);
          log("âœ“ Triangle rendered successfully!", "success");

          setStatus("Rendering Complete âœ“", true);
          log(
            "=== Test Complete: WebGPU rendering pipeline functional ===",
            "success",
          );

          // Animate (rotate colors based on time)
          let frame = 0;
          function animate() {
            render(device, context, pipeline, vertexBuffer);
            frame++;
            if (frame % 60 === 0) {
              log(`Frame ${frame} rendered`, "info");
            }
            requestAnimationFrame(animate);
          }

          // Start animation
          log("Starting animation loop...", "info");
          animate();
        } catch (error) {
          log(`âœ— Fatal error: ${error.message}`, "error");
          setStatus("Failed", false);
          console.error(error);
        }
      }

      main();
    </script>
  </body>
</html>
